#  SQLD

### ▷ 데이터 모델과 성능

* 성능 데이터 모델링의 개요

1. 성능 데이터 모델링의 정의
   - 데이터베이스 성능향상을 목적으로 설계단계의 데이터 모델링 때 부터 정규화,반정규화, 테이블통합, 테이블분할, 조인구조, PK, FK 등 여러 가지 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것

2. 성능 데이터 모델링 고려사항

   - 데이터 모델링을 할 떄 정규화를 정확하게 수행한다.
   - 데이터베이스 용량산정을 수행한다.
   - 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.
   - 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.
   - 이력모델의 조정, PK/FK조정, 슈퍼타입/서브타입 조정등을 수행한다.
   - 성능관점에서 데이터 모델을 검증한다.

   

- 정규화와 성능

1. 정규화를 통한 성능 향상 전략
   - 정규화 하는 이유 -> 데이터 중복 제거 ,관심사별로 처리되는 경우가 많아 성능이 향상 
   - 일반적으로 정규화를 수행해야 데이터 처리 선능이 향상 
   - 데이터의 조회처리 트랜잭션시에 성능저하가 나타날 수 있음
2. 함수적 종속성(Functional Dependency)에 근거한 정규화 수행 필요
   - 함수적 종속성 : 데이터들이 어떤 기준값에 의해 종속되는 현상을 지칭하는 것
     - 기준값 : 결정자(Determinant) , 종속되는 값 : 종속자(Dependent)
     - 결정자 -> 종속자 ( 종속자는 근본적으로 결정자에 함수적으로 종속성을 가지고 있음)
     - ex) 주민등록번호 - > 이름 출생지 주소 



- 반정규화와 성능
1. 반정규화를 통한 성능향상 전략 

   - 반정규화의 정의

     - 정규화를 수행하지 않은 모델
     - 정규화된 엔터티, 속성, 관계에 대해 시스템의 성능 향상과 개발과 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법

   - 데이터 무결성이 깨질 수 있는 위험을 무릎쓰고 반정규화를 적용하는 이유

     - 데이터 조회할 때 디스크 I/O량이 많아 성능이 저하
     - 경로가 멀어 조인으로 인한 성능 저하
     - 칼럼을 계산하여 읽을때 성능 저하 
     - 중복성의 원리를 활용하여 데이터조회시 성능을 향상시키는 역할을 할 수 있음

   - 반정규화를 기술적으로 수행하지 않은 경우

     - 성능이 저하된 DB가 생성 될 수 있음
     - 구축단계나 시험단계에서 반정규화를 적용할 때 수정에 따른 노력비용이 많이 들게 됨

   - 반정규화의 적용방법

     - 보통 칼럼 중복을 통해서만 반정규화 수행 

     - 반정규화를 과도하게 적용하면 데이터 무결성이 깨짐

     - 적용방법

       1. 반정규화의 대상을 조사한다.
          - 자주 사용되는 테이블에 접근하는 프로세스의 수가 많고 항상 일정한 범위만을 조회하는 경우에 반정규화를 검토한다.
          - 테이블에 대량의 데이터가 있고 대량의 데이터 범위를 자주 처리하는 경우에 처리범위를 일정하게 줄이지 않으면 성능 보장을 보장 할 수 없을 경우
          - 통계성 프로세스에 의해 통계 정보를 필요로 할 때 별도의 통계 테이블(반정규화테이블)을 생성
          - 테이블에 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우

       2. 반정규화의 대상에 대해 다른 방법으로 처리할 수 있는지 검토한다.
          - 지나치게 많은 조인 -> view사용
          - 대량의 데이터 처리나 부분처리에 의한 성능 저하 -> 클러스터링(조회중심 테이블에만) or 인덱스 조정
          - 대량의 데이터 -> PK의 성격에 따라 부분적인 테이블로 분리(파티셔닝 기법) 
          - 응용 애플리케이션에서 로직을 구사하는 방법을 변경
       3. 반정규화를 적용한다.
          - 반정규화를 하는 대상 - 테이블, 속성, 관계에 대해 적용



- 반정규화 기법

1. 테이블 반정규화
   - 테이블 병합
     - 1:1 관계 테이블 병합 - 1:1 관계를 통합하여 성능 향상
     - 1:M 관계 테이블 병합 - 1:M 관계를 통합하여 성능 향상
     - 슈퍼/ 서브타입 테이블 병합 - 슈퍼/ 서브 관계를 통합하여 성능 향상
   - 테이블 분할
     - 수직분할 - 테이블을  1:1로 분리하여 성능향상 
     - 수평분할 - 로우 단위로 테이블을 쪼갬
   - 테이블 추가
     - 중복테이블 추가 - 다른 업무 or다른 서버일 경우 동일한 테이블구조를 중복 -> 원격조인 제거하여 성능 향상
     - 통계테이블 추가 - sum avg등 미리 수행하여 계산해 둠으로써 조회 시 성능 향상
     - 이력테이블 추가 - 마스터 테이블에 존재하는 레코드를 중복 
     - 부분테이블 추가 - 자주 이용하는 칼럼들을 모아놓은 별도의 반정규화된 테이블 생성
   - 칼럼 반정규화
     - 중복칼럼 추가 - 조인 감소를 위해 중복된 칼럼 위치
     - 파생칼럼 추가 - 계산에 의해 발생되는 성능저하 예방 -> 미리 값을 계산 칼럼에 보관 (Derived Column)
     - 이력테이블 칼럼 추가 - 대량의 이력데이터 처리할때 불특정 날 조회나 최근 값 조회 할때 나타나는 성능 저하 예방 - > 기능성칼럼 추가
     - PK에 의한 칼럼 추가 - 복합의미를 갖는 PK를 단일속성으로 구성했을때 발생, 단일 PK안에서 특정값을 별도로 조회하는 경우 성능 저하 -> 일반속성으로 포함하는 방법
     - 응용시스템 오작동을 위한 칼럼 추가 - 업부적으로 의미 X 사용자가 데이터처리를 잘못해 원래 값으로 복하길 원할때 -> 이전 데이터를 임시적으로 중복하여 보관하는 기법 
   - 관계 반정규화
     - 중복관계 추가 - 데이터처리 위해 여러경로 거쳐 조인 가능 but 성능저하 -> 추가적인 관계를 맺는 방법
     - 관계의 반정규화는 데이터 무결서 깨뜨릴 위험을 갖지 않고서도 데이터 처리의 성능을 향상 시킬 수 있는 반정규화 기법

- 대량 데이터에 따른 성능

1. 대량 데이터 발생에 따른 테이블 분할 개요
   - 대량의 데이터가 존재하는 테이블에 많은 트랜잭션이 발생하여 성능이 저하 되는 테이블 구조에 대해 수평/수직 분할 설계를 통해 성능저하를 예방할 수 있음
   - 많은 칼럼은 로우체이닝과 로우마이그레이션이 많아지게 되어 성능이 저하됨
     - 로우 체이닝 : 로우 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태
     - 로우마이그레이션 : 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식

2. 한 테이블에 많은 수의 칼럼을 가지고 있는 경우
   - 1:1 관계로 분리함으로써 성능향상이 가능하도록 해야함
3.  대량 데이터 저장 및 처리로 인해 성능
   - RANGE PARTITION 적용
     - 가장 많이 사용하는 파티셔닝
     - 데이터보관주기에 따라 테이블에 데이터를 쉽게 지우는 것이 가능 
   - LIST PARTITION 적용
     - 대용량 데이터를 특정값에 따라 분리 저장 가능
     - 데이터보관주기에 따라 쉽게 삭제하는 기능 X
   - HASH PARTITION 적용
     - 지정된 HASH조건에 따라 해슁 알고리즘이 적용되어 테이블이 분리되며 설계자는 테이블에 데이터가 정확하게 어떻게 들어갔는지 알 수 X
     -  데이터보관주기에 따라 쉽게 삭제하는 기능 X



4. 테이블에 대한 수평분할/ 수직분할의 절차

   - 데이터 모델링을 완성한다.

   - 데이터베이스 용량산정을 한다.

   - 대향 데이터가 처리되는 테이블에 대해서 트랜잭션 처리 패턴을 분석한다.

   - 칼럼 단위로 집중화된 처리가 발생하는지, 로우단위로 집중화된 처리 발생되는지 분석하여 집중화된 단위로 테이블을 분리하는 것을 검토한다.

     - 특정테이블이 대용량인 경우 - > 테이블 1:1형태로 분리

     - 컬럼 수는 적지만 데이터 용량 많으면 -> 파티셔닝 

       

- 데이터 베이스 구조와 성능

1. 슈퍼타입/ 서브타입 모델의 성능고려 방법

   - 슈퍼/서브 타입 데이터 모델의 개요 

     - Extended ER모델
     - 공통의 부분을 슈퍼타임으로 모델링
     - 분석단계에서 많이 쓰임 
     - 논리적인 데이터 모델에서 이용되는 형태

   - 슈퍼/서브타입 데이터 모델의 변환

     - 슈퍼/서브타입에 대한 변환을 잘못하면 성능 저하되는 이유 -> 트랜잭션 특성을 고려하지 않고 테이블이 설계되었기 때문
       - 트랜잭션은 항상 일괄로 처리하는데 테이블은 개별로 유지되어 Union연산에 의해 성능이 저하
       - 트랜잭션은 항상 서브타입 개별로 처리하는데 테이블을 하나로 통합되어 있어 불필요하게 많은 양의 데이터가 집약되어 있어 성능이 저하
       - 트랜잭션은 항상 슈퍼 + 서브 타입을 공통으로 처리하는데 개별로 유지되어 있거나 하나의 테이블로 집약되어 있어 성능이 저하
     - 변환 기준은? 데이터의양 & 트랜잭션의 유형

   - 슈퍼/서브 타입 데이터 모델의 변환기술

     - 논리적인 데이터 모델에서 설계한 슈퍼/서브타입 모델을 물리적인 데이터 모델로 전환할때 어떤 유형의 트랜잭션이 발생하는지 검증 해야함  

       1\) 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성 - OneToOne Type

       ​	- 확장성 : 우수함 , 조인성능 : 나쁨, I/O량성능 : 좋음, 관리용이성 : 좋지 않음

       2\) 슈퍼 + 서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼+서브 타입 테이블로 구성  - Plus Type

       ​	- 확장성 : 보통 , 조인성능 : 나쁨, I/O량성능 : 좋음, 관리용이성 : 좋지 않음

       3\) 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성 - Single Type

       ​	- 확장성 : 나쁨 , 조인성능 : 우수함, I/O량성능 : 나쁨, 관리용이성 : 좋음(1개)



- 인덱스 특성을 고려한 PK/FK 데이터베이스 성능 향상

1. PK/FK 칼럼 순서와 성능 개요
   - 인덱스 : 데이터를 조회할 때 가장 효과적으로 처리될 수 있도록 접근경로를 제공하는 오브젝트
   - 테이블에 발생되는 트랜잭션의 조회 패턴에 따라 PK/FK 칼럼의 순서를 조정해야함

2. PK칼럼의 순서를 조정하지 않으면 성능이 저하 되는 이유
   - 테이블에 접근하는 트랜잭션의 특징에 효율적이지 않은 인덱스가 생성되어 있으므로 인덱스 의 범위를 넓게 이용하거나 Full Scan을 유발하게 되어 성능이 저하된다

3. PK 순서를 잘못 지정하여 성능이 저하된 경우 - 간단한 오류
   - PK 순서 변경 -> 인덱스 이용가능 

4. PK 순서를 잘못 지정하여 서능이 저하된 경우 -복잡한 오류
   - 인덱스를 얼마나 효율적으로 이요하는지 검증 필요
   - 인덱스 순서 고려 후 PK 순서 수정 하여 성능 개선
5. 물리적인 테이블에 FK제약이 걸려있지 않을 경우 인덱스 미생성으로 성능저하
   - 물리적인 테이블에 FK제약이 걸려있을 때 반드시 FK인덱스 생성
   - FK제약이 걸려있지 않을 경우 FK 인데스를 생성하는것은 기본 정책으로 하되 발생되는 트랜잭션에 의해 거의 활용되지 않을 때에만 FK 인덱스를 지우는 방법으로 하는 것이 적절한 방법 



- 분산 데이터베이스와 성능

1. 분산 데이터베이스의 개요
   - 여러 곳으로 분산되어있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스
   - 논리적으로 동일한 시스템에 속하지만, 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터들의 모임. 물리적 site 분산, 논리적으로 사용자 통합.공유

2. 분산 데이터베이스의 투명성(Transparency)
   - 분할 투명성(단편화) : 하나의 논리적 Relation이 여러 단편으로 분할되어 각 단편의 사본이 여러 site에 저장
   - 위치 투명성 : 사용하려는 데이터의 저장 장소 명시 불필요. 위치 정보가 System Catalog에 유지되어야 함 
   - 지역사상 투명성 : 지역DBMS와 물리적 DB사이의 Mapping 보장, 각 지역시스템이름과 무관한 이름 사용가능 
   - 중복 투명성 : DB객체가 여러 site에 중복 되어 있는지 알 필요가 없는 성질
   - 장애 투명성 : 구성요소(DBMS,Computer)의 장애에 무관한 Transaction의 원자성 유지
   - 병생 투명성 : 다수 Transaction 동시 수생시 결과의 일관성 유지, Time Stamp, 분산 2단계 Locking을 이용 구현 

3. 분산 데이터 베이스의 적용 방법 및 장단점
   - 분산 데이터베이스 적용 방법
     - 업무 의 흐름을 보고 업무구성에 따른 아키텍처 특징에 따라 데이터베이스를 구성하는 것
   - 분산 데이터베이스 장단점
     - 장점 
       - 지역 자치성, 점중적 시스템 용량 확장
       - 신뢰성과 가용성
       - 효용성과 융통성
       - 빠른 응답 속도와 통신비용 절감
       - 데이터의 가용성과 신뢰성 증가
       - 시스템 규모의 적절한 조절
       - 각 지역 사용자의 요구 수용 증대
     - 단점
       - 소프트웨어 개발 비용
       - 오류의 잠재성 증대
       - 처리비용의 증대
       - 설계, 관리의 복잡성과 비용
       - 불규칙한 응답속도
       - 통제의 어려움
       - 데이터 무결성에 대한 위협
4. 분산 데이터베이스의 적용 기법
   - 테이블 위치 분산
     - 테이블의 구조는 변하지 않는다. 
     - 테이블이 다른 데이터베이스에 중복되어 생성X
     - 설계된 테이블의 위치를 각각 다르게 위치 시키는 것 
     - 테이블의 위치를 파악할 수 있는 도식화된 위치별 DB문서가 필요
   - 테이블 분할 분산
     - 각각의 테이블을 쪼개어 분산
     - 수평분할 
       - 로우 단위로 분리 
       - 칼럼은 분리 X
     - 수직분할
       - 칼럼을 기준으로 분리 
       - 로우는 분리X
       - 각각의 테이블에는 동일한 Primary Key구조와 값을 가지고 있어야 한다
     - 테이블 복제 분산 
       - 동일한 테이블을 다른 지역이나 서버에서 동시에 생성하여 관리하는 유형
       - 부분복제
         - 통합된 테이블을 한군데에 가지고 있으면서 각 지사별로는 지사에 해당된 로우를 가지고 있는 형태 
         - 지사에 존재하는 데이터는 반드시 본사에 존재해야함 
         - 많이 사용하는 분산 기법
         - 지사에서 입력 수정 삭제가 발생
         - 많은 시간 소요
       - 광역복제
         - 통합된 테이블을 한군데 (본사) 에 가지고 있으면서 각 지사에도 본사와 동일한 데이터를 모두 가지고 있는 형태
         - 지사에 존재하는 데이터는 반드시 본사에 존재해야함 
         - 지사 ,본사 데이터량 동일
         - 많이 사용 
         - 본사에서 입력 수정 삭제 발생 
         - 많은 시간 소요
       - 테이블 요약 분산
         - 지역간에 또는 서버간에 데이터가 비슷하지만 서로 다른 유형으로 존재하는 경우 
         - 분석요약
           - 각 지사별로 존재하는 요약정보를 본사에 통합하여 다시 전체에 대해서 요약정보를 산출하는 분산 방법
         - 통합요약
           - 각 지사별로 존재하는 다른 내용의 정보를 본사에 통함하여 다시 전체에 대해서 요약정보를 산출하는 방법
5. 분산 데이터베이스를 적용하여 성능 향상
   - 성능이 중요한 사이트에 적용해야 한다.
   - 공통코드, 기준정보, 마스터 데이터 등에 대해 분산환경을 구성하면 성능이 좋아진다.
   - 실시간 동기화 요구되지 않을 때 좋다. 거의 실시간(New Real Time)의 업무적인 특징을 가지고 있을 때도 분산 환경을 구성할 수 있다.
   - 특정 서버에 부하가 집중이 될 때 부하를 분산할 때도 좋다.
   - 백업 사이트 (Disaster Recovery Site)를 구성할 때 간단하게 분산기능을 적용하여 구성할 수 있다.